# Создайте иерархию классов с использованием множественного наследования. Выведите на экран порядок разрешения
# методов для каждого из классов. Объясните, почему линеаризации данных классов выглядят именно так.


class A:
	def __init__(self) -> None:
		print('"A" -> Конструктор базового (абстрактного) класса')


class B(A):
	def __init__(self) -> None:
		print('"B" -> Конструктор класса')

		super(B, self).__init__()
		print('"B" -> Выше конструктор класса -> "A" вызваный из класса')


class C:
	def __init__(self) -> None:
		print('"С" -> Конструктор базового (абстрактного) класса')


class D(A, C):
	def __init__(self) -> None:
		print('"D" -> Конструктор класса')

		super(A, self).__init__()
		print('Выше конструктор класса -> "C" вызваный из класса -> "A" с множественным наследованием и принципом MRO')


if __name__ == '__main__':
	class_a = A()
	class_b = B()
	class_ab = D()
